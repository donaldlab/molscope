#version 450


layout(push_constant, std140) uniform readonly restrict Bounds {
	// (with padding to align vec3s at 16-byte boundaries)
	vec3 min; // in world space
	float pad0;
	vec3 max;
	float pad1;
} inBounds;

// define the spherical input atoms
// TODO: add cylinder occluders?

struct Atom {
	vec3 pos;
	float radius;
};

layout(binding = 0, std140) buffer readonly restrict Atoms {
	uint size;
	uint pad0; // 12 bytes padding so buf is aligned to 16 bytes
	uint pad1; // NOTE: don't do uint pad[3] here, that apparently screws up the alignment
	uint pad2;
	Atom buf[];
} inAtoms;

layout(binding = 1, std140) buffer readonly restrict Lines {
	uint size;
	uint pad0; // 12 bytes padding so buf is aligned to 16 bytes
	uint pad1; // NOTE: don't do uint pad[3] here, that apparently screws up the alignment
	uint pad2;
	vec4 buf[];
} inLines;

layout(binding = 2, std140) buffer readonly restrict Samples {
	uvec4 size;
	uvec4 buf[];
} inSamples;

layout(binding = 3, r32i) uniform restrict iimage3D outOcclusion;


#include "math.glsl"


// p is sphere center
// r is sphere radius
// v is ray vector
// returns the parameters of the line/ray along v at the (up to) two intersection points
float[2] intersect(vec3 p, float r, vec3 v) {

	// see math/ambient-occlusion.wxm for derivation
	float a1 = v.x*v.x;
	float a2 = v.y*v.y;
	float a3 = v.z*v.z;
	float a4 = 1/(a3+a2+a1);
	float a5 = -(p.y*p.y);
	float a6 = -(p.z*p.z);
	float a7 = r*r;
	float a8 = -(p.x*p.x);
	float a9 = (a7+a5+a8)*a3+(2*p.y*p.z*v.y+2*p.x*p.z*v.x)*v.z+(a7+a6+a8)*a2+2*p.x*p.y*v.x*v.y+(a7+a6+a5)*a1;
	float[2] result;
	if (a9 < 0) {
		result[0] = NAN;
		result[1] = NAN;
	} else {
		float a10 = sqrt(a9);
		float a11 = p.z*v.z;
		float a12 = p.y*v.y;
		float a13 = p.x*v.x;
		// NOTE: the order of operations here apparently has a big effect on the solution accuracy
		// the roundoff error must be very ill-conditioned here! =(
		result[0] = a4*(((-a10 +a11)+a12)+a13);
		result[1] = a4*((( a10 +a11)+a12)+a13);
	}
	return result;
}

const uint SIDE_NEG = 0;
const uint SIDE_POS = 1;

bool[2] getHit(float[2] t) {
	bool result[2];
	result[SIDE_NEG] = (!isnan(t[0]) && t[0] < 0) || (!isnan(t[1]) && t[1] < 0);
	result[SIDE_POS] = (!isnan(t[0]) && t[0] >= 0) || (!isnan(t[1]) && t[1] >= 0);
	return result;
}


// shoot rays in all directions from each sample point
// what percentage of rays are obscured by atom spheres?
// bin rays by cardinal direction

void main() {

	// read our sample and line
	uvec3 iSample = inSamples.buf[gl_GlobalInvocationID.x].xyz;
	uint iLine = gl_GlobalInvocationID.y;

	// convert the sample index to a position in world space within the bounds
	vec3 p = inBounds.min + vec3(iSample)*(inBounds.max - inBounds.min)/vec3(inSamples.size.xyz - uvec3(1));

	// cast both rays on this line
	bool castingNeg = true;
	bool castingPos = true;

	for (uint ia=0; ia<inAtoms.size; ia++) {
		Atom atom = inAtoms.buf[ia];

		// transform the atom into a coord system relative to the ray source
		vec3 pos = atom.pos - p;

		// intersect the atom sphere and line
		bool[2] hit = getHit(intersect(pos, atom.radius, inLines.buf[iLine].xyz));

		// update rays based on side hits
		if (hit[SIDE_NEG] && castingNeg) {
			castingNeg = false;
		}
		if (hit[SIDE_POS] && castingPos) {
			castingPos = false;
		}

		// if we're done casting, we can stop early
		if (!castingNeg && !castingPos) {
			break;
		}
	}

	// update occlusion counts for both rays
	int occlusions = 0;
	if (!castingNeg) {
		occlusions++;
	}
	if (!castingPos) {
		occlusions++;
	}
	imageAtomicAdd(outOcclusion, ivec3(iSample), occlusions);
}
